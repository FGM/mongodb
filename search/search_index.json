{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MongoDB suite for Drupal The MongoDB suite for Drupal 8 is a set of modules enabling the storage of various types of data on a Drupal\u00ae site in MongoDB\u00ae. This comes in addition to the standard SQL storage used by Drupal. It comprises several Drupal modules, each implementing a specific functionality. With the exception of the base mongodb module, upon which all others depend because it provides the standardized connection service to Drupal, all the modules are independent of each other except where indicated. The mongodb module is not just the basis for this package: it is also designed to ease the development of bespoke code for end-user projects, providing Drupal-integrated Symfony\u00ae services for Client and Database with a familiar alias-based selection, like those provided by Drupal core for the SQL database drivers. Modules Existing Module In a word Information mongodb driver Client and Database services, tests base mongodb_storage key-value Key-value store, with server-side expiration mongodb_watchdog logger PSR-3 compliant logger with a built-in UI Planned Modules expected to be ported to 8.x-2.x in some release after 2.0 include: Module In a word Information mongodb_cache cache Cache storage, with server-side expiration mongodb_lock lock Lock plugin mongodb_path path Path plugin Future directions This module has no direct equivalent in earlier versions, but its development is being considered. Module Information mongodb_debug Provides low-level debug information. A D7 version exists on mongodb_logger but depends on the legacy mongo PHP extension. Futures versions will need the 1.4 version of the mongodb extension which implements the MongoDB APM specification . Legal information This suite of modules is licensed under the General Public License, v2.0 or later (GPL-2.0-or-later). MongoDB is a registered trademark of MongoDB Inc. Drupal is a registered trademark of Dries Buytaert. Symfony is a registered trademark of Symfony SAS.","title":"Home"},{"location":"#mongodb-suite-for-drupal","text":"The MongoDB suite for Drupal 8 is a set of modules enabling the storage of various types of data on a Drupal\u00ae site in MongoDB\u00ae. This comes in addition to the standard SQL storage used by Drupal. It comprises several Drupal modules, each implementing a specific functionality. With the exception of the base mongodb module, upon which all others depend because it provides the standardized connection service to Drupal, all the modules are independent of each other except where indicated. The mongodb module is not just the basis for this package: it is also designed to ease the development of bespoke code for end-user projects, providing Drupal-integrated Symfony\u00ae services for Client and Database with a familiar alias-based selection, like those provided by Drupal core for the SQL database drivers.","title":"MongoDB suite for Drupal"},{"location":"#modules","text":"","title":"Modules"},{"location":"#existing","text":"Module In a word Information mongodb driver Client and Database services, tests base mongodb_storage key-value Key-value store, with server-side expiration mongodb_watchdog logger PSR-3 compliant logger with a built-in UI","title":"Existing"},{"location":"#planned","text":"Modules expected to be ported to 8.x-2.x in some release after 2.0 include: Module In a word Information mongodb_cache cache Cache storage, with server-side expiration mongodb_lock lock Lock plugin mongodb_path path Path plugin","title":"Planned"},{"location":"#future-directions","text":"This module has no direct equivalent in earlier versions, but its development is being considered. Module Information mongodb_debug Provides low-level debug information. A D7 version exists on mongodb_logger but depends on the legacy mongo PHP extension. Futures versions will need the 1.4 version of the mongodb extension which implements the MongoDB APM specification .","title":"Future directions"},{"location":"#legal-information","text":"This suite of modules is licensed under the General Public License, v2.0 or later (GPL-2.0-or-later). MongoDB is a registered trademark of MongoDB Inc. Drupal is a registered trademark of Dries Buytaert. Symfony is a registered trademark of Symfony SAS.","title":"Legal information"},{"location":"bespoke/","text":"Bespoke code Beyond the simple use cases covered by this standard package, most uses of MongoDB in Drupal projects appear in enteprise-class bespoke developments. Until this version, this usually meant totally custom code, built either straight from the legacy mongo extension, the current mongodb extension, or on top of the PHP Library or the Doctrine ODM for MongoDB, suffering from a total lack of integration with the underlying core Drupal CMS. This module provides a degree of version independence for the API changes in PHP library . Refer to the Drupal\\mongodb\\MongoDb class for an example. Starting with 8.x-2.0, such one-off code can be developed on top of the base mongodb module: unlike earlier releases, 8.x-2.x uses the PHP-standard connection methods and options, without deviation, adding only a thin layer of Drupal adaptation on top of the standard mongodb extension and PHP library . Example The familiar Drupal alias mechanism for databases is available to provide easy, string-referenced access to Client and Database instances through the package-provided ClientFactory and DatabaseFactory services respectively. Most such code is likely to be service based, so the example given below demonstrates a service bar in module foo , using a custom foo-database database aliased as foodb , to keep its storage separate from the main database used by the package modules, and its logic independent of other Drupal modules. Per-environment settings The site local settings file includes the alias definition, binding it to the actual database credentials, allowing for per-environment configuration: <?php // settings.local.php $settings['mongodb'] = [ 'clients' => [ // Client alias => constructor parameters. 'default' => [ 'uri' => 'mongodb://localhost:27017', 'uriOptions' => [], 'driverOptions' => [], ], ], 'databases' => [ // Collection alias => [ client_alias, collection_name ] 'default' => ['default', 'drupal'], 'logger' => ['default', 'logger'], 'foodb' => ['default', 'foo-database'], ], ]; With such a configuration, the foodb alias is available to all MongoDB-using modules in the site, possibly pointing to different databases depending on the environment (development, staging, production...). Service-based module adapter The foo.services.yml service file for the bespoke foo.module can then reference foodb to access the database with a constant alias, regardless of the environment: // modules/custom/Foo/foo.services.yml services: foo.storage: class: 'MongoDB\\Database' factory: ['@mongodb.database_factory', 'get'] arguments: ['foodb'] foo.bar: class: 'Drupal\\foo\\Bar' arguments: ['@foo.storage', '@logger.channel.foo'] foo.baz: class: 'Drupal\\foo\\Baz' arguments: ['@foo.storage', '@mongodb.logger'] This allows services in the module to access the database in both function code for Drupal hooks, and OO code for component-level logic without having to be environment-aware. If the mongodb_watchdog module is enabled: the @logger.channel.foo logger instance passed to the Bar constructor will be a Drupal-standard LoggerChannel instance, dispatching events to all active loggers in the site. This is the service most \"classic\" Drupal applications will want to use, as it has no visible dependence on MongoDB. . the @mongodb.logger logger instance passed to the Baz constructor will be a PSR-3-standard logger only writing to MongoDB instead of logging through the central Drupal logging channel mechanism, but still providing the standard Drupal UI to examine the application logs. When using this service, the type option MUST be set in the message context to appear as a logging channel in the Drupal logs UI. This is the service applications written in a \"decoupled components\" style will prefer. In both cases, code receiving such a logger service by dependency injection should type-hint it to the PSR-3 LoggerInterface . Component logic Finally, the component application logic can use the services without receiving any Drupal-specific dependency. In this example, we can simply assume the service code is located within the module itself, for simplicity: <?php // modules/custom/Foo/src/Bar.php use MongoDb\\Database; use Psr\\Log\\LoggerInterface; public function __construct(Database $database, LoggerInterface $logger) { $this->database = $database; $this->logger = $logger; } public function baz() { // Perform some business logic using $this->database. // Log it using $this->logger. } Having the code only receive standard services (like a PSR-3 logger) or PHP library classes allows it to be written as an agnostic component that can be brought in using Composer and shared with non-Drupal code. This is often useful in bespoke projects, which tend to combine Drupal with other parts of the application written in Laravel 5 or Symfony 4, since the code has no Drupal-specific dependency in that case, only exposing a PSR-3 standard API. Tests The mongodb module provides a MongoDbTestBase base test class allowing kernel-based integration tests, as described on the tests page.","title":"Bespoke code"},{"location":"bespoke/#bespoke-code","text":"Beyond the simple use cases covered by this standard package, most uses of MongoDB in Drupal projects appear in enteprise-class bespoke developments. Until this version, this usually meant totally custom code, built either straight from the legacy mongo extension, the current mongodb extension, or on top of the PHP Library or the Doctrine ODM for MongoDB, suffering from a total lack of integration with the underlying core Drupal CMS. This module provides a degree of version independence for the API changes in PHP library . Refer to the Drupal\\mongodb\\MongoDb class for an example. Starting with 8.x-2.0, such one-off code can be developed on top of the base mongodb module: unlike earlier releases, 8.x-2.x uses the PHP-standard connection methods and options, without deviation, adding only a thin layer of Drupal adaptation on top of the standard mongodb extension and PHP library .","title":"Bespoke code"},{"location":"bespoke/#example","text":"The familiar Drupal alias mechanism for databases is available to provide easy, string-referenced access to Client and Database instances through the package-provided ClientFactory and DatabaseFactory services respectively. Most such code is likely to be service based, so the example given below demonstrates a service bar in module foo , using a custom foo-database database aliased as foodb , to keep its storage separate from the main database used by the package modules, and its logic independent of other Drupal modules.","title":"Example"},{"location":"bespoke/#per-environment-settings","text":"The site local settings file includes the alias definition, binding it to the actual database credentials, allowing for per-environment configuration: <?php // settings.local.php $settings['mongodb'] = [ 'clients' => [ // Client alias => constructor parameters. 'default' => [ 'uri' => 'mongodb://localhost:27017', 'uriOptions' => [], 'driverOptions' => [], ], ], 'databases' => [ // Collection alias => [ client_alias, collection_name ] 'default' => ['default', 'drupal'], 'logger' => ['default', 'logger'], 'foodb' => ['default', 'foo-database'], ], ]; With such a configuration, the foodb alias is available to all MongoDB-using modules in the site, possibly pointing to different databases depending on the environment (development, staging, production...).","title":"Per-environment settings"},{"location":"bespoke/#service-based-module-adapter","text":"The foo.services.yml service file for the bespoke foo.module can then reference foodb to access the database with a constant alias, regardless of the environment: // modules/custom/Foo/foo.services.yml services: foo.storage: class: 'MongoDB\\Database' factory: ['@mongodb.database_factory', 'get'] arguments: ['foodb'] foo.bar: class: 'Drupal\\foo\\Bar' arguments: ['@foo.storage', '@logger.channel.foo'] foo.baz: class: 'Drupal\\foo\\Baz' arguments: ['@foo.storage', '@mongodb.logger'] This allows services in the module to access the database in both function code for Drupal hooks, and OO code for component-level logic without having to be environment-aware. If the mongodb_watchdog module is enabled: the @logger.channel.foo logger instance passed to the Bar constructor will be a Drupal-standard LoggerChannel instance, dispatching events to all active loggers in the site. This is the service most \"classic\" Drupal applications will want to use, as it has no visible dependence on MongoDB. . the @mongodb.logger logger instance passed to the Baz constructor will be a PSR-3-standard logger only writing to MongoDB instead of logging through the central Drupal logging channel mechanism, but still providing the standard Drupal UI to examine the application logs. When using this service, the type option MUST be set in the message context to appear as a logging channel in the Drupal logs UI. This is the service applications written in a \"decoupled components\" style will prefer. In both cases, code receiving such a logger service by dependency injection should type-hint it to the PSR-3 LoggerInterface .","title":"Service-based module adapter"},{"location":"bespoke/#component-logic","text":"Finally, the component application logic can use the services without receiving any Drupal-specific dependency. In this example, we can simply assume the service code is located within the module itself, for simplicity: <?php // modules/custom/Foo/src/Bar.php use MongoDb\\Database; use Psr\\Log\\LoggerInterface; public function __construct(Database $database, LoggerInterface $logger) { $this->database = $database; $this->logger = $logger; } public function baz() { // Perform some business logic using $this->database. // Log it using $this->logger. } Having the code only receive standard services (like a PSR-3 logger) or PHP library classes allows it to be written as an agnostic component that can be brought in using Composer and shared with non-Drupal code. This is often useful in bespoke projects, which tend to combine Drupal with other parts of the application written in Laravel 5 or Symfony 4, since the code has no Drupal-specific dependency in that case, only exposing a PSR-3 standard API.","title":"Component logic"},{"location":"bespoke/#tests","text":"The mongodb module provides a MongoDbTestBase base test class allowing kernel-based integration tests, as described on the tests page.","title":"Tests"},{"location":"install/","text":"Installation and Settings Prerequisites The MongoDB module and sub-modules need some configuration to be useful. This guide assumes that : A MongoDB 3.0 to 4.2.x server instance is already installed, configured and available for connection from the Drupal instance. The site will be running Drupal 8.8.x or 8.9.x, with Drush 9.x. The mongodb (not mongo ) PHP extension version 1.4 or later is installed and configured. PHP is version 7.2.x to 7.3.x. PHP 7.4.x might work but is not tested: be sure to report any issue you could have with it. We recommend using Composer for installing this module. Check out the MongoDB extension and library for PHP Installing MongoDB itself is best explained in these official resources maintained by MongoDB Inc.: MongoDB Mac installation MongoDB LINUX installation MongoDB Windows installation If MongoDB 3.0 to 3.5 1 is installed on localhost:27017 and you started the mongod with the \u2013httpinterface option, you may view the web admin interface: http://localhost:28017/ Settings Configuration Download the module package, as per Installing contributed modules (Drupal 8) Copy the relevant section from mongodb/example.settings.local.php to your settings.local.php file if you use one, or settings.php otherwise, and adapt it to match your MongoDB settings. These settings are used by the mongodb module to connect to your MongoDB servers, with the default server being the one started in previous steps. The clients key contains an associative array of connection by connection alias, with the default connection parameters being under the default key, and additional keys allowing the use of other servers/clusters. The databases key contains an associative array of server/database pairs by database alias, with the default Drupal database being under the default key, and additional keys allowing modules to use their own database to avoid stepping on each other's toes. This is especially useful for bespoke modules created for the needs of a specific site, which can thus use their own databases, possibly located on other MongoDB clusters. For example, with the following settings: // In sites/default/settings.local.php. $settings['mongodb'] = [ 'clients' => [ // Client alias => connection constructor parameters. 'default' => [ 'uri' => 'mongodb://localhost:27017', 'uriOptions' => [], 'driverOptions' => [], ], ], 'databases' => [ // Database alias => [ client_alias, database_name ] 'default' => ['default', 'drupal'], 'keyvalue' => ['default', 'keyvalue'], 'logger' => ['default', 'logger'], ], ]; With these settings: The default database alias will handle collections in the drupal database on the default MongoDB server installed in earlier steps. The keyvalue database alias will store key-value collections on the same default MongoDB server, but in a separate keyvalue database. The logger database alias will store logger collections on the same default MongoDB server, but in a separate logger database. The module contains an example default implementation of these settings, which you can copy or include, in mongodb/example.settings.local.php . Once the module is installed and enabled, you can check its requirements on /admin/reports/status : Installing using Composer If you are already using Composer in your site to manage module dependencies, installing is just a two-steps process: At the root of your site, add this package: # Stable version composer require \"drupal/mongodb:^2.0.0\" # Latest version composer require \"drupal/mongodb:dev-2.x\" Enable the mongodb module. You now have access to the MongoDB services and Drush/Console commands for the mongodb module. This option is deprecated from 3.6 version on. \u21a9","title":"Installation"},{"location":"install/#installation-and-settings","text":"","title":"Installation and Settings"},{"location":"install/#prerequisites","text":"The MongoDB module and sub-modules need some configuration to be useful. This guide assumes that : A MongoDB 3.0 to 4.2.x server instance is already installed, configured and available for connection from the Drupal instance. The site will be running Drupal 8.8.x or 8.9.x, with Drush 9.x. The mongodb (not mongo ) PHP extension version 1.4 or later is installed and configured. PHP is version 7.2.x to 7.3.x. PHP 7.4.x might work but is not tested: be sure to report any issue you could have with it. We recommend using Composer for installing this module. Check out the MongoDB extension and library for PHP Installing MongoDB itself is best explained in these official resources maintained by MongoDB Inc.: MongoDB Mac installation MongoDB LINUX installation MongoDB Windows installation If MongoDB 3.0 to 3.5 1 is installed on localhost:27017 and you started the mongod with the \u2013httpinterface option, you may view the web admin interface: http://localhost:28017/","title":"Prerequisites"},{"location":"install/#settings-configuration","text":"Download the module package, as per Installing contributed modules (Drupal 8) Copy the relevant section from mongodb/example.settings.local.php to your settings.local.php file if you use one, or settings.php otherwise, and adapt it to match your MongoDB settings. These settings are used by the mongodb module to connect to your MongoDB servers, with the default server being the one started in previous steps. The clients key contains an associative array of connection by connection alias, with the default connection parameters being under the default key, and additional keys allowing the use of other servers/clusters. The databases key contains an associative array of server/database pairs by database alias, with the default Drupal database being under the default key, and additional keys allowing modules to use their own database to avoid stepping on each other's toes. This is especially useful for bespoke modules created for the needs of a specific site, which can thus use their own databases, possibly located on other MongoDB clusters. For example, with the following settings: // In sites/default/settings.local.php. $settings['mongodb'] = [ 'clients' => [ // Client alias => connection constructor parameters. 'default' => [ 'uri' => 'mongodb://localhost:27017', 'uriOptions' => [], 'driverOptions' => [], ], ], 'databases' => [ // Database alias => [ client_alias, database_name ] 'default' => ['default', 'drupal'], 'keyvalue' => ['default', 'keyvalue'], 'logger' => ['default', 'logger'], ], ]; With these settings: The default database alias will handle collections in the drupal database on the default MongoDB server installed in earlier steps. The keyvalue database alias will store key-value collections on the same default MongoDB server, but in a separate keyvalue database. The logger database alias will store logger collections on the same default MongoDB server, but in a separate logger database. The module contains an example default implementation of these settings, which you can copy or include, in mongodb/example.settings.local.php . Once the module is installed and enabled, you can check its requirements on /admin/reports/status :","title":"Settings Configuration"},{"location":"install/#installing-using-composer","text":"If you are already using Composer in your site to manage module dependencies, installing is just a two-steps process: At the root of your site, add this package: # Stable version composer require \"drupal/mongodb:^2.0.0\" # Latest version composer require \"drupal/mongodb:dev-2.x\" Enable the mongodb module. You now have access to the MongoDB services and Drush/Console commands for the mongodb module. This option is deprecated from 3.6 version on. \u21a9","title":"Installing using Composer"},{"location":"layout/","text":"Project layout .coveralls.yml # Code coverage configuration file .scrutinizer.yml # Scrutinizer configuration file .gitignore # Git ignore file .travis.yml # Travis build configuration file README.md # Current Readme file composer.json # Composer configuration file core.phpunit.xml # PHPUnit configuration file docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files example.settings.local.php # Example settings to connect to MongoDB mkdocs.yml # The Mkdocs configuration file modules/ # mongodb # Driver mongodb_storage # Key-value mongodb_watchdog # Logger","title":"Layout"},{"location":"layout/#project-layout","text":".coveralls.yml # Code coverage configuration file .scrutinizer.yml # Scrutinizer configuration file .gitignore # Git ignore file .travis.yml # Travis build configuration file README.md # Current Readme file composer.json # Composer configuration file core.phpunit.xml # PHPUnit configuration file docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files example.settings.local.php # Example settings to connect to MongoDB mkdocs.yml # The Mkdocs configuration file modules/ # mongodb # Driver mongodb_storage # Key-value mongodb_watchdog # Logger","title":"Project layout"},{"location":"tests/","text":"PHPUnit The newly ported modules have some test coverage, which can be checked with PHPUnit. Writing custom tests The mongodb module provides a Drupal\\Tests\\mongodb\\Kernel\\MongoDbTestBase base class on which to build custom kernel tests for bespoke modules, as it provides a per-test database created during test setUp() , and dropped during tearDown() . The base class is documented on the mongodb documentation page. Complete test example This example show how to write a test using a custom foo database for the eponymous module foo , assuming individual tests do not drop the database instance themselves. <?php namespace Drupal\\\\Tests\\foo\\Kernel; use Drupal\\mongodb\\MongoDb; use Drupal\\Tests\\mongodb\\Kernel\\MongoDbTestBase; /** * @coversDefaultClass \\Drupal\\foo\\Foo * * @group foo */ class FooTest extends MongoDbTestBase { const MODULE = 'foo'; public static $modules = [ MongoDb::MODULE, static::MODULE, ]; /** * The test database. */ protected $database; /** * Override getSettingsArray method to include custom test database */ public function getSettingsArray(): array { $settings = parent::getSettingsArray(); $settings[MongoDb::MODULE]['databases']['foo_alias'] = [ static::CLIENT_TEST_ALIAS, $this->getDatabasePrefix(), ]; return $settings; } /** * Add a custom alias to settings and instantiate a custom database. * * If the tests do not need a specific database, no setUp()/tearDown() is * even needed. */ public function setUp() { parent::setUp(); $this->database = new DatabaseFactory( new ClientFactory($this->settings), $this->settings )->get(static::MODULE); } /** * Drop the custom database. * * If the tests do not need a specific database, no setUp()/tearDown() is * even needed. */ public function tearDown() { $this->database->drop(); parent::tearDown(); } /** * @covers ::whatever */ public function testWhatever() { // ... custom test logic... } } In most cases, modules implementing will implement multiple classes, hence have multiple tests, in which case having a per-module base test class will be recommended. See mongodb_storage or mongodb_watchdog tests for examples. Running tests Now that Simpletest is for all intents and purposes deprecated since Drupal 8.6, and its UI apparently going away (cf #2566767 ), tests should be run from the PHPUnit command line. Running directly The typical full command to run tests looks like the next example ( \\ is to avoid too long a line). Assuming a composer-project deployment with Drupal in the web/ directory, you'll need to run phpunit from the Drupal root, not the project root: cd web SIMPLETEST_BASE_URL=http://localhost \\ BROWSERTEST_OUTPUT_DIRECTORY=/some/writable/pre-existing/path \\ SIMPLETEST_DB=mysql://user:pass@localhost/drupal8 \\ MONGODB_URI=mongodb://somemongohost:27017 \\ ../vendor/bin/phpunit -c $PWD/core/phpunit.xml.dist \\ -v --debug --coverage-clover=/tmp/cover.xml \\ modules/contrib/mongodb Functional tests: the SIMPLETEST_BASE_URL and BROWSERTEST_OUTPUT_DIRECTORY variables are needed. Kernel and Unit tests do not need them. Optional: MONGODB_URI points to a working MongoDB instance. If it is not provided, the tests will default to mongodb://localhost:27017 . These variables can also be set in the core/phpunit.xml custom configuration file to simplify the command line, as described on Drupal.org Running PHPUnit tests page. Using a phpunit.xml configuration file The test command can also be simplified using a phpunit.xml configuration file: phpunit -c core/phpunit.xml Or to generate a coverage report: phpunit -c core/phpunit.xml --coverage-html=/some/coverage/path modules/contrib/mongodb In this syntax, core/phpunit.xml is a local copy of the default mongodb/core.phpunit.xml configuration file, tweaked for the local environment.","title":"Tests"},{"location":"tests/#phpunit","text":"The newly ported modules have some test coverage, which can be checked with PHPUnit.","title":"PHPUnit"},{"location":"tests/#writing-custom-tests","text":"The mongodb module provides a Drupal\\Tests\\mongodb\\Kernel\\MongoDbTestBase base class on which to build custom kernel tests for bespoke modules, as it provides a per-test database created during test setUp() , and dropped during tearDown() . The base class is documented on the mongodb documentation page.","title":"Writing custom tests"},{"location":"tests/#complete-test-example","text":"This example show how to write a test using a custom foo database for the eponymous module foo , assuming individual tests do not drop the database instance themselves. <?php namespace Drupal\\\\Tests\\foo\\Kernel; use Drupal\\mongodb\\MongoDb; use Drupal\\Tests\\mongodb\\Kernel\\MongoDbTestBase; /** * @coversDefaultClass \\Drupal\\foo\\Foo * * @group foo */ class FooTest extends MongoDbTestBase { const MODULE = 'foo'; public static $modules = [ MongoDb::MODULE, static::MODULE, ]; /** * The test database. */ protected $database; /** * Override getSettingsArray method to include custom test database */ public function getSettingsArray(): array { $settings = parent::getSettingsArray(); $settings[MongoDb::MODULE]['databases']['foo_alias'] = [ static::CLIENT_TEST_ALIAS, $this->getDatabasePrefix(), ]; return $settings; } /** * Add a custom alias to settings and instantiate a custom database. * * If the tests do not need a specific database, no setUp()/tearDown() is * even needed. */ public function setUp() { parent::setUp(); $this->database = new DatabaseFactory( new ClientFactory($this->settings), $this->settings )->get(static::MODULE); } /** * Drop the custom database. * * If the tests do not need a specific database, no setUp()/tearDown() is * even needed. */ public function tearDown() { $this->database->drop(); parent::tearDown(); } /** * @covers ::whatever */ public function testWhatever() { // ... custom test logic... } } In most cases, modules implementing will implement multiple classes, hence have multiple tests, in which case having a per-module base test class will be recommended. See mongodb_storage or mongodb_watchdog tests for examples.","title":"Complete test example"},{"location":"tests/#running-tests","text":"Now that Simpletest is for all intents and purposes deprecated since Drupal 8.6, and its UI apparently going away (cf #2566767 ), tests should be run from the PHPUnit command line.","title":"Running tests"},{"location":"tests/#running-directly","text":"The typical full command to run tests looks like the next example ( \\ is to avoid too long a line). Assuming a composer-project deployment with Drupal in the web/ directory, you'll need to run phpunit from the Drupal root, not the project root: cd web SIMPLETEST_BASE_URL=http://localhost \\ BROWSERTEST_OUTPUT_DIRECTORY=/some/writable/pre-existing/path \\ SIMPLETEST_DB=mysql://user:pass@localhost/drupal8 \\ MONGODB_URI=mongodb://somemongohost:27017 \\ ../vendor/bin/phpunit -c $PWD/core/phpunit.xml.dist \\ -v --debug --coverage-clover=/tmp/cover.xml \\ modules/contrib/mongodb Functional tests: the SIMPLETEST_BASE_URL and BROWSERTEST_OUTPUT_DIRECTORY variables are needed. Kernel and Unit tests do not need them. Optional: MONGODB_URI points to a working MongoDB instance. If it is not provided, the tests will default to mongodb://localhost:27017 . These variables can also be set in the core/phpunit.xml custom configuration file to simplify the command line, as described on Drupal.org Running PHPUnit tests page.","title":"Running directly"},{"location":"tests/#using-a-phpunitxml-configuration-file","text":"The test command can also be simplified using a phpunit.xml configuration file: phpunit -c core/phpunit.xml Or to generate a coverage report: phpunit -c core/phpunit.xml --coverage-html=/some/coverage/path modules/contrib/mongodb In this syntax, core/phpunit.xml is a local copy of the default mongodb/core.phpunit.xml configuration file, tweaked for the local environment.","title":"Using a phpunit.xml configuration file"},{"location":"modules/mongodb/","text":"Driver: mongodb The mongodb module is the main module in the suite, providing a thin Drupal adapter for the standard MongoDB PHP library, in the form of two Symfony factory services and a base test class. Factories The basic idea of these factory services is to provide a way to create instances of the standard MongoDB Client and Database classes from a simple alias string, taking all properties from the Drupal standard Settings object. This allows code to be unaware of the execution environment, referring to database or client by a functional alias, while the specifics of accessing the relevant mongod / mongos and database are left to per-environment settings, Drupal\\mongodb\\DatabaseFactory : The recommended entry point for most applications, returning a MongoDb\\Database from an alias string. __construct(ClientFactory $clientFactory, Settings $settings) . This is normally invoked by the container, to which the class is exposed as the mongodb.database_factory service. get(string $dbAlias): MongoDb\\Database ; returns a Database instance matching the value defined in Drupal settings for $dbAlias . Drupal\\mongodb\\ClientFactory : This one may be needed for more complex applications, e.g. those wishing to handle operations spanning connections to multiple MongoDB replica sets/sharded clusters. __construct(Settings $settings) . This is normally invoked by the container, to which the class is exposed as the mongodb.client_factory service. get(string $alias): MongoDb\\Client : returns a Client instance matching the value defined in Drupal settings for $alias . Troubleshooting commands: The module provides two commands designed to help troubleshoot issues and access the contents of the MongoDB databases. Both are available for Drush and Drupal Console indifferently. drush mongodb:settings reports how the module suite sees the settings. It needs no parameters, and returns YAML output looking like this: clients: default: uri: 'mongodb://localhost:27017' uriOptions: { } driverOptions: { } databases: default: - default - drupal keyvalue: - default - keyvalue logger: - default drush mongodb:find <db_alias> <collection> <selector> allows running a MongoDB query from the command line on the chosen database alias and collection, returning the results as YAML, as in the following example. Note that passing JSON selectors from the bash command lines requires escaping as in that example: $ drush mongodb:find keyvalue kvp_state '{ \"_id\": \"node.min_max_update_time\" }' - _id: node.min_max_update_time value: 'a:2:{s:11:\"min_created\";N;s:11:\"max_created\";N;}'$ $ Test base class The module provides a \\Drupal\\Tests\\mongodb\\Kernel\\MongoDbTestBase extending core class KernelTestBase . This allows modules to define their own integration tests using the module services, and taking advantage of running in a per-test database. What it actually provides: Test instance properties: $this->uri contains a MongoDB URI suitable for connecting to a default client, taken from the value of the MONGODB_URI variable is passed in the environment, on the PHPUnit command line, or in the phpunit.xml configuration file, this will be its value, otherwise it will be set to the traditional MongoDB default instance: mongodb://localhost:27017 . $this->settings contains a test-specific instance of core Settings , limited to the mongodb settings key. The default database in these settings is a temporary database defined by the Simpletest prefix, allowing it to be used without interacting with the rest of the site, and dropped during test teardown. Constants: in addition to the ones used by the mongodb tests, the base test defines constants usable by child tests: CLIENT_TEST_ALIAS is the alias for the default MongoDB test client DB_DEFAULT_ALIAS is the alias for the default test database Modules: The test base enables the mongodb modules, since all modules using MongoDB are expected to depend on it. Module tests will typically want their own module enabled, so they will need to redefine static::$modules including the mongodb module as done in Drupal\\Tests\\mongodb_storage\\Kernel\\KeyValueTestBase and Drupal\\Tests\\mongodb_watchdog\\Kernel\\LoggerTest . setUp() / tearDown() : Tests need to invoke parent::setUp() near the top of their own setUp() , to have the test base define the properties before doing their own work. Tests need to invoke parent::tearDown() near the end of their own tearDown() - if any - to drop the default test database. Tests needing non-default test databases need to override the getSettingsArray() function to add their own database alias after invoking parent::setUp() , and need to drop that database during their own tearDown() . They can use $this->getTestDatabaseName($postfix) method to build a per-test database name that will not collide with the default database. There are examples for this in the mongodb_watchdoig tests. A complete example of how to write a test using that base class is given on the tests page.","title":"Driver: mongodb"},{"location":"modules/mongodb/#driver-mongodb","text":"The mongodb module is the main module in the suite, providing a thin Drupal adapter for the standard MongoDB PHP library, in the form of two Symfony factory services and a base test class.","title":"Driver: mongodb"},{"location":"modules/mongodb/#factories","text":"The basic idea of these factory services is to provide a way to create instances of the standard MongoDB Client and Database classes from a simple alias string, taking all properties from the Drupal standard Settings object. This allows code to be unaware of the execution environment, referring to database or client by a functional alias, while the specifics of accessing the relevant mongod / mongos and database are left to per-environment settings, Drupal\\mongodb\\DatabaseFactory : The recommended entry point for most applications, returning a MongoDb\\Database from an alias string. __construct(ClientFactory $clientFactory, Settings $settings) . This is normally invoked by the container, to which the class is exposed as the mongodb.database_factory service. get(string $dbAlias): MongoDb\\Database ; returns a Database instance matching the value defined in Drupal settings for $dbAlias . Drupal\\mongodb\\ClientFactory : This one may be needed for more complex applications, e.g. those wishing to handle operations spanning connections to multiple MongoDB replica sets/sharded clusters. __construct(Settings $settings) . This is normally invoked by the container, to which the class is exposed as the mongodb.client_factory service. get(string $alias): MongoDb\\Client : returns a Client instance matching the value defined in Drupal settings for $alias .","title":"Factories"},{"location":"modules/mongodb/#troubleshooting-commands","text":"The module provides two commands designed to help troubleshoot issues and access the contents of the MongoDB databases. Both are available for Drush and Drupal Console indifferently. drush mongodb:settings reports how the module suite sees the settings. It needs no parameters, and returns YAML output looking like this: clients: default: uri: 'mongodb://localhost:27017' uriOptions: { } driverOptions: { } databases: default: - default - drupal keyvalue: - default - keyvalue logger: - default drush mongodb:find <db_alias> <collection> <selector> allows running a MongoDB query from the command line on the chosen database alias and collection, returning the results as YAML, as in the following example. Note that passing JSON selectors from the bash command lines requires escaping as in that example: $ drush mongodb:find keyvalue kvp_state '{ \"_id\": \"node.min_max_update_time\" }' - _id: node.min_max_update_time value: 'a:2:{s:11:\"min_created\";N;s:11:\"max_created\";N;}'$ $","title":"Troubleshooting commands:"},{"location":"modules/mongodb/#test-base-class","text":"The module provides a \\Drupal\\Tests\\mongodb\\Kernel\\MongoDbTestBase extending core class KernelTestBase . This allows modules to define their own integration tests using the module services, and taking advantage of running in a per-test database. What it actually provides: Test instance properties: $this->uri contains a MongoDB URI suitable for connecting to a default client, taken from the value of the MONGODB_URI variable is passed in the environment, on the PHPUnit command line, or in the phpunit.xml configuration file, this will be its value, otherwise it will be set to the traditional MongoDB default instance: mongodb://localhost:27017 . $this->settings contains a test-specific instance of core Settings , limited to the mongodb settings key. The default database in these settings is a temporary database defined by the Simpletest prefix, allowing it to be used without interacting with the rest of the site, and dropped during test teardown. Constants: in addition to the ones used by the mongodb tests, the base test defines constants usable by child tests: CLIENT_TEST_ALIAS is the alias for the default MongoDB test client DB_DEFAULT_ALIAS is the alias for the default test database Modules: The test base enables the mongodb modules, since all modules using MongoDB are expected to depend on it. Module tests will typically want their own module enabled, so they will need to redefine static::$modules including the mongodb module as done in Drupal\\Tests\\mongodb_storage\\Kernel\\KeyValueTestBase and Drupal\\Tests\\mongodb_watchdog\\Kernel\\LoggerTest . setUp() / tearDown() : Tests need to invoke parent::setUp() near the top of their own setUp() , to have the test base define the properties before doing their own work. Tests need to invoke parent::tearDown() near the end of their own tearDown() - if any - to drop the default test database. Tests needing non-default test databases need to override the getSettingsArray() function to add their own database alias after invoking parent::setUp() , and need to drop that database during their own tearDown() . They can use $this->getTestDatabaseName($postfix) method to build a per-test database name that will not collide with the default database. There are examples for this in the mongodb_watchdoig tests. A complete example of how to write a test using that base class is given on the tests page.","title":"Test base class"},{"location":"modules/mongodb_storage/","text":"Key-value: mongodb_storage The mongodb_storage module implements the Key-Value storage for Drupal in MongoDB. Configuration To use the MongoDB Key-Value (Expirable) storage: ensure there is a keyvalue database alias as in settings configuration . declare MongoDB as the default Key-Value storage implementation by editing the existing declarations in the sites/default/services.yml file: # In sites/default/services.yml. factory.keyvalue: default: keyvalue.mongodb factory.keyvalue.expirable: keyvalue_expirable_default: keyvalue.expirable.mongodb enable the module, e.g. using drush en mongodb_storage . import the existing Key-Value contents from the database, using the Drush or Console mongodb:storage:import_keyvalue command: drush most-ikv . It will output the names of the imported stores, for your information: key_value key_value_expire rebuild the container to take these changes into account using drush cr . Command The module provides one single command to import the content of the default SQL storage for Key-Value into MongoDB. The command is available for Drush and Drupal Console indifferently, and is described in the previous paragraph as part of the configuration steps.","title":"Key-value: mongodb_storage"},{"location":"modules/mongodb_storage/#key-value-mongodb_storage","text":"The mongodb_storage module implements the Key-Value storage for Drupal in MongoDB.","title":"Key-value: mongodb_storage"},{"location":"modules/mongodb_storage/#configuration","text":"To use the MongoDB Key-Value (Expirable) storage: ensure there is a keyvalue database alias as in settings configuration . declare MongoDB as the default Key-Value storage implementation by editing the existing declarations in the sites/default/services.yml file: # In sites/default/services.yml. factory.keyvalue: default: keyvalue.mongodb factory.keyvalue.expirable: keyvalue_expirable_default: keyvalue.expirable.mongodb enable the module, e.g. using drush en mongodb_storage . import the existing Key-Value contents from the database, using the Drush or Console mongodb:storage:import_keyvalue command: drush most-ikv . It will output the names of the imported stores, for your information: key_value key_value_expire rebuild the container to take these changes into account using drush cr .","title":"Configuration"},{"location":"modules/mongodb_storage/#command","text":"The module provides one single command to import the content of the default SQL storage for Key-Value into MongoDB. The command is available for Drush and Drupal Console indifferently, and is described in the previous paragraph as part of the configuration steps.","title":"Command"},{"location":"modules/mongodb_watchdog/","text":"Logger: mongodb_watchdog The mongodb_watchdog module stores the log entries for your Drupal site in MongoDB collections as mentioned in Settings Configuration This module uses a separate database, defined by the logger database alias in settings. Do NOT point that alias to the same database as default , because the module Drops the logger database when uninstalling, which would drop all your other data with it. Configuration Below are the configurable items available in mongodb_watchdog.settings mongodb.watchdog.items the maximum item limit on the capped collection used by the module. if not defined, it defaults to 10000. the actual (size-based) limit is derived from this value, assuming 1 kiB per watchdog entry. mongodb.watchdog.limit the maximum severity level (0 to 7, per RFC 5424) to save into the logger storage. events below this level (with a higher numerical level) will be ignored by the module. if not defined, all events will saved. mongodb.watchdog.items_per_page the maximum number of events displayed on the event details page. mongodb_watchdog.request_tracking if true, enable the per-request event tracking. if not defined, it defaults to false because its cost is not entirely negligible. this feature requires the use of mod_unique_id in Apache 2.x mongodb_watchdog.requests if request tracking is enabled, this setting defines the maximum requests limit on the capped collection used by the module. if not defined, it defaults to 100000. the actual (size-based) limit is derived from this variable, assuming 1 kiB per tracker entry. See Drupal\\Core\\Logger\\RfcLogLevel and Psr\\Log\\LogLevel for further information about severity levels. Troubleshooting command The module provides one single command designed to help troubleshoot issues with logging when this module is enabled. It is available for Drush and Drupal Console indifferently. The command takes no arguments and returns an analysis of the logger collections which needs to be interpreted. $ drush mongodb:watchdog:sanitycheck 0: 0 1: 2 1000: 1 2000: 0 3000: 0 4000: 0 5000: 0 6000: 0 7000: 0 8000: 0 9000: 0 9999: 0 10000: 0 $ What the output of this command represents is the number of watchdog_event_* collections with a document count in the range specified as the key. In the results, the first and last two entries are specific: they match exact counts, while the others are intervals, so the actual buckets are: 0 , 1 , 2..1000 , 1001..2000 , ..., 9001..9998 , 9999 , 10000 . The specific value 10000 is the number of entries allowed in event collections, as these are MongoDB capped collections: whatever its value n , the command will report 0 , 1 , n-1 , n , and 9 ranges in between. Interpreting the results As a general rule, on a high-load site, all buckets should have comparable numbers, and the number of events logged grouped by pattern is pseudo-random, except for the 0 bucket, which should be empty. 0 bucket non-empty: unless there was specific manipulation performed by hand, this is a bug, and should be reported: event collections are created when an event is created, by the first insertion, and dropped as needed, but never truncated or created without an insert. 1 bucket has a high value, possibly orders of magnitude higher than other buckets. This denotes an incorrect use of the Drupal logger system, for which the PSR-3 message parameter is a message template, and the variant part of the message is expressed as placeholder values in the options. Look for calls to log operations passing a variable as the message and replace them by a template containing placeholders for the variable content in the message. n-1 bucket has a high value: suspicious situation with the logger, especially if the \"n\" value is low or 0: please report a possible bug, with accompanying data n bucket has a high value n-1 has a high value too: this is a mostly normal situation, especially if the value in the previous bucket is also high, although it means the data rotation in your site is possibly a bit high and you should increase the size of the capped collections to ensure longer retention of data. n-1 has a low or 0 value: your logs are saturated by the site, and you are losing information, as all the capped collections in that situation are rolling over constantly. Ensure you have enough storage and raise the value capped collection size. The config value to change in these cases is mongodb.watchdog.items .","title":"Logger: mongodb_watchdog"},{"location":"modules/mongodb_watchdog/#logger-mongodb_watchdog","text":"The mongodb_watchdog module stores the log entries for your Drupal site in MongoDB collections as mentioned in Settings Configuration This module uses a separate database, defined by the logger database alias in settings. Do NOT point that alias to the same database as default , because the module Drops the logger database when uninstalling, which would drop all your other data with it.","title":"Logger: mongodb_watchdog"},{"location":"modules/mongodb_watchdog/#configuration","text":"Below are the configurable items available in mongodb_watchdog.settings mongodb.watchdog.items the maximum item limit on the capped collection used by the module. if not defined, it defaults to 10000. the actual (size-based) limit is derived from this value, assuming 1 kiB per watchdog entry. mongodb.watchdog.limit the maximum severity level (0 to 7, per RFC 5424) to save into the logger storage. events below this level (with a higher numerical level) will be ignored by the module. if not defined, all events will saved. mongodb.watchdog.items_per_page the maximum number of events displayed on the event details page. mongodb_watchdog.request_tracking if true, enable the per-request event tracking. if not defined, it defaults to false because its cost is not entirely negligible. this feature requires the use of mod_unique_id in Apache 2.x mongodb_watchdog.requests if request tracking is enabled, this setting defines the maximum requests limit on the capped collection used by the module. if not defined, it defaults to 100000. the actual (size-based) limit is derived from this variable, assuming 1 kiB per tracker entry. See Drupal\\Core\\Logger\\RfcLogLevel and Psr\\Log\\LogLevel for further information about severity levels.","title":"Configuration"},{"location":"modules/mongodb_watchdog/#troubleshooting-command","text":"The module provides one single command designed to help troubleshoot issues with logging when this module is enabled. It is available for Drush and Drupal Console indifferently. The command takes no arguments and returns an analysis of the logger collections which needs to be interpreted. $ drush mongodb:watchdog:sanitycheck 0: 0 1: 2 1000: 1 2000: 0 3000: 0 4000: 0 5000: 0 6000: 0 7000: 0 8000: 0 9000: 0 9999: 0 10000: 0 $ What the output of this command represents is the number of watchdog_event_* collections with a document count in the range specified as the key. In the results, the first and last two entries are specific: they match exact counts, while the others are intervals, so the actual buckets are: 0 , 1 , 2..1000 , 1001..2000 , ..., 9001..9998 , 9999 , 10000 . The specific value 10000 is the number of entries allowed in event collections, as these are MongoDB capped collections: whatever its value n , the command will report 0 , 1 , n-1 , n , and 9 ranges in between.","title":"Troubleshooting command"},{"location":"modules/mongodb_watchdog/#interpreting-the-results","text":"As a general rule, on a high-load site, all buckets should have comparable numbers, and the number of events logged grouped by pattern is pseudo-random, except for the 0 bucket, which should be empty. 0 bucket non-empty: unless there was specific manipulation performed by hand, this is a bug, and should be reported: event collections are created when an event is created, by the first insertion, and dropped as needed, but never truncated or created without an insert. 1 bucket has a high value, possibly orders of magnitude higher than other buckets. This denotes an incorrect use of the Drupal logger system, for which the PSR-3 message parameter is a message template, and the variant part of the message is expressed as placeholder values in the options. Look for calls to log operations passing a variable as the message and replace them by a template containing placeholders for the variable content in the message. n-1 bucket has a high value: suspicious situation with the logger, especially if the \"n\" value is low or 0: please report a possible bug, with accompanying data n bucket has a high value n-1 has a high value too: this is a mostly normal situation, especially if the value in the previous bucket is also high, although it means the data rotation in your site is possibly a bit high and you should increase the size of the capped collections to ensure longer retention of data. n-1 has a low or 0 value: your logs are saturated by the site, and you are losing information, as all the capped collections in that situation are rolling over constantly. Ensure you have enough storage and raise the value capped collection size. The config value to change in these cases is mongodb.watchdog.items .","title":"Interpreting the results"}]}