<?php
// $Id$

/**
 * @file
 * Implementation of the field storage API for MongoDB.
 */

/**
 * Implement hook_field_storage_info().
 */
function mongodb_field_storage_field_storage_info() {
  return array(
    'mongodb_field_storage' => array(
      'label' => t('MongoDB field storage'),
      'description' => t('Stores nodes and fields in a MongoDB database.'),
    ),
  );
}

/**
 * Implement hook_field_storage_details().
 */
function mongodb_field_storage_field_storage_details($field) {
  // We probably want to implement that at one point, but this is informative only.
}

/**
 * Get the collection used to store fields current values.
 */
function _mongodb_field_storage_collection($type = 'current') {
  return mongodb_collection("fields_" . $type);
}

/**
 * Implement hook_field_storage_create_field().
 */
function mongodb_field_storage_field_storage_create_field($field) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_update_field().
 */
function mongodb_field_storage_field_storage_update_field($field, $prior_field, $has_data) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_delete_field().
 */
function mongodb_field_storage_field_storage_delete_field($field) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_load().
 */
function mongodb_field_storage_field_storage_load($obj_type, $objects, $age, $fields, $options) {
  $load_current = $age == FIELD_LOAD_CURRENT;

  // Fetch information about the fields and prepare the keys.
  $keys = array();
  $field_names = array();
  $saved_fields = array();
  foreach ($fields as $field_id => $ids) {
    $field = field_info_field_by_id($field_id);
    $saved_fields[$field_id] = $field;

    // Add this fields' id to the list.
    foreach ($ids as $id) {
      $keys[$obj_type . ':' . $id] = TRUE;
    }
  }

  // Execute the query and save the fields to the parent object.
  $collection = $load_current ? _mongodb_field_storage_collection('current') : _mongodb_field_storage_collection('revision');
  $result = $collection->find(array('_id' => array('$in' => array_keys($keys))));

  foreach ($result as $id => $object) {
    $object_type = $object['_type'];
    $entity_id = $object['_entity_id'];
    foreach ($saved_fields as $field_id => $field) {
      $field_name = $field['field_name'];
      $field_values = array();
      if (isset($object[$field_name])) {
        // Restore the field structure.
        if ($field['cardinality'] == 1 && is_scalar($object[$field_name])) {
          if (count($field['columns']) == 1) {
            $column_name = current(array_keys($field['columns']));
          }
          else {
            // Let's figure out what column is this. We stored a scalar if the
            // type is distinctive enough. For example, text fields have a value
            // and a format but the format is not edited for simple textfields
            // so we save the value as a scalar. And we know it belongs to
            // value because it's a string. Format would be an integer.
            $value = $object[$field_name];
            $other = FALSE;
            $special_types = array('int' => 0, 'float' => 1);
            if (is_int($value)) {
              $type = 'int';
            }
            elseif (is_float($value)) {
              $type = 'float';
            }
            else {
              $other = TRUE;
            }
            foreach ($field['columns'] as $_column_name => $_column_data) {
              $_type = $_column_data['type'];
              if ((!$other && $type == $_type) || ($other && !isset($special_types[$_type]))) {
                $column_name = $_column_name;
                break;
              }
            }
          }
          $field_values[LANGUAGE_NONE][0][$column_name] = $object[$field_name];
        }
        else {
          foreach ($object[$field_name] as $column_values) {
            $language = isset($column_values['_language']) ? $column_values['_language'] : LANGUAGE_NONE;
            $delta = isset($column_values['_delta']) ? $column_values['_delta'] : 0;
            unset($column_values['_language'], $column_values['_delta']);
            $field_values[$language][$delta] = $column_values;
          }
        }
      }
      $objects[$entity_id]->{$field_name} = $field_values;
    }
  }
}

/**
 * Implement hook_field_storage_write().
 */
function mongodb_field_storage_field_storage_write($obj_type, $object, $op, $fields, $entity_write = FALSE) {
  $wrote = &drupal_static(__FUNCTION__, array());
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($obj_type, $object);
  // There is always a field_attach_insert/update call followed by an
  // entity_insert/update. field_attach does not call storage_write needlessly
  // so we need to make sure if the entity was not saved during field_attach,
  // it will be during entity write. The static is set during attach write if
  // one happened and always unset on entity write.
  if ($entity_write) {
    if (isset($wrote[$obj_type][$entity_id])) {
      unset($wrote[$obj_type][$entity_id]);
      return;
    }
  }
  else {
    $wrote[$obj_type][$entity_id] = TRUE;
  }

  // Create a new object.
  $new_object = new stdClass();
  $new_object->_id = $obj_type . ':' . $entity_id;
  $new_object->_entity_id = intval($entity_id);
  $new_object->_type = $obj_type;
  $new_object->_bundle = $bundle;
  if (isset($revision_id)) {
    $new_object->_revision_id = intval($revision_id);
  }

  // Add the base table's fields to the new object.
  $entity_info = entity_get_info($obj_type);
  // Although it's rare not to define a base table, test entities for sure
  // don't.
  if (isset($entity_info['base table'])) {
    $table_schema = drupal_get_schema($entity_info['base table']);
    foreach ($table_schema['fields'] as $field_name => $column_definition) {
      if (isset($object->$field_name)) {
        $new_object->$field_name = _mongodb_field_storage_value($column_definition['type'], $object->$field_name);
      }
    }
  }

  // Add the fieldapi fields to the new object
  foreach ($fields as $field_id) {
    $field = field_info_field_by_id($field_id);
    $field_name = $field['field_name'];
    $field_values = array();
    if (isset($object->$field_name)) {
      // Singular values are stored as scalars because MongoDB can't index
      // multiple arrays.
      $stored = FALSE;
      if ($field['cardinality'] == 1 && count($object->$field_name) == 1 && isset($object->{$field_name}[LANGUAGE_NONE][0]) && count($object->{$field_name}[LANGUAGE_NONE][0]) == 1) {
        list ($column_name, $value) = each($object->{$field_name}[LANGUAGE_NONE][0]);
        if (isset($field['columns'][$column_name])) {
          // If the type is distinctive then we can go ahead even if there are
          // multiple columns. For example, text fields have a value and a
          // format but the format is not edited for simple textfields so we
          // save the value as a scalar. And we know it belongs to value
          // because it's a string. Format would be an integer.
          $type = $field['columns'][$column_name]['type'];
          $special_types = array('int' => 0, 'float' => 1);
          $can_store = TRUE;
          foreach ($field['columns'] as $_column_name => $_column_data) {
            // Check the other columns.
            if ($_column_name != $column_name) {
              $_type = $_column_data['type'];
              // There is a problem if both are int, if both are float, if
              // neither is int or float.
              if (($type == 'int' && $_type == 'int') ||
                  ($type == 'float' && $_type == 'float') ||
                  (!isset($special_types[$type]) && !isset($special_types[$_type]))) {
                $can_store = FALSE;
                break;
              }
            }
          }
          if ($can_store) {
            $field_values = _mongodb_field_storage_value($field['columns'][$column_name], $value);
            $stored = TRUE;
          }
        }
      }
      if (!$stored) {
        foreach ($object->$field_name as $language => $values) {
          // According to field.test, we should not save anything for NULL.
          if (isset($values)) {
            foreach ($values as $delta => $column_values) {
              // We have to make sure we don't store invalid deltas.
              if ($delta >= 0 && ($field['cardinality'] <= 0 || $delta < $field['cardinality'])) {
                foreach ($column_values as $column_name => $column_value) {
                  if (isset($field['columns'][$column_name])) {
                    $column_values[$column_name] = _mongodb_field_storage_value($field['columns'][$column_name]['type'], $column_values[$column_name]);
                  }
                }
                // Collapse the field structure.
                if ($language != LANGUAGE_NONE) {
                  $column_values['_language'] = $language;
                }
                if ($delta != 0) {
                  $column_values['_delta'] = $delta;
                }
                $field_values[] = $column_values;
              }
            }
          }
        }
      }
    }
    $new_object->$field_name = $field_values;
  }

  // Save the object.
  _mongodb_field_storage_collection('current')->save($new_object);
  if (isset($revision_id)) {
    $new_object->_id = $obj_type . ':' . $revision_id;
    _mongodb_field_storage_collection('revision')->save($new_object);
  }
}

function _mongodb_field_storage_value($type, $value) {
  switch ($type) {
    case 'int':
    case 'serial':
      return intval($value);
    case 'float':
      return floatval($value);
    default:
      return $value;
  }
}


/**
 * Implement hook_field_storage_delete().
 *
 * This function deletes data for all fields for an object from the database.
 */
function mongodb_field_storage_field_storage_delete($obj_type, $object, $fields) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($obj_type, $object);
  _mongodb_field_storage_collection('current')->remove(array(
    '_id' => $obj_type . ':' . $entity_id,
  ));
  _mongodb_field_storage_collection('revision')->remove(array(
    '_type' => $obj_type,
    '_entity_id' => $entity_id,
  ));
}

/**
 * Implement hook_field_storage_delete_revision().
 *
 * This function actually deletes the data from the database.
 */
function mongodb_field_storage_field_storage_delete_revision($obj_type, $object, $fields) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($obj_type, $object);
  _mongodb_field_storage_collection('revision')->remove(array(
    '_id' => $obj_type . ':' . $revision_id,
  ));
}

/**
 * Implement hook_field_storage_delete_instance().
 *
 * This function simply marks for deletion all data associated with the field.
 */
function mongodb_field_storage_field_storage_delete_instance($instance) {
  // TODO: figure out what to do.
}

/**
 * Implement hook_field_storage_query().
 */
function mongodb_field_storage_field_storage_query($field_id, $conditions, $options) {
  $load_current = $options['age'] == FIELD_LOAD_CURRENT;

  $field = field_info_field_by_id($field_id);
  $field_name = $field['field_name'];

  $collection = $load_current ? _mongodb_field_storage_collection('current') : _mongodb_field_storage_collection('revision');

  $partial_query = array();

  foreach ($conditions as $condition) {
    // A condition is either a (column, value, operator) triple, or a
    // (column, value) pair with implied operator.
    @list($column, $value, $operator) = $condition;

    // MongoDB doesn't easily supports multiple conditions on the same field.
    if (isset($partial_query[$column])) {
      throw new FieldQueryException(t("Unsupported query: MongoDB doesn't support multiple conditions on the same column."));
    }

    if ($column == 'language') {
      // Language is stored in a private field.
      $column = '_language';
    }

    if (!$operator) {
      $operator = is_array($value) ? 'IN' : '=';
    }

    $simple_operators = array(
      '!=' => '$ne',
      '>' => '$gt',
      '>=' => '$gte',
      '<' => '$lt',
      '<=' => '$lte',
      'IN' => '$in',
      'NOT IN' => '$nin',
    );

    if ($operator == '=') {
      $partial_query[$column] = $value;
    }
    elseif (isset($simple_operators[$operator])) {
      $partial_query[$column][$simple_operators[$operator]] = $value;
    }
    elseif ($operator == 'BETWEEN') {
      $partial_query[$column] = array(
        '$lte' => $value[0],
        '$gte' => $value[1],
      );
    }
    else if ($operator == 'STARTS_WITH') {
      $partial_query[$column] = new MongoRegex('/^' . preg_quote($value) . '/');
    }
    else if ($operator == 'ENDS_WITH') {
      $partial_query[$column] = new MongoRegex('/' . preg_quote($value) . '$/');
    }
    else if ($operator == 'CONTAINS') {
      $partial_query[$column] = new MongoRegex('/' . preg_quote($value) . '/');
    }
    else {
      throw new FieldQueryException(t("Unsupported query: unsupported opperator %operator.", array('%operator' => $operator)));
    }
  }

  $partial_query = (object) $partial_query;

  // Build a query with a partial match to the field.
  $query = array();

  // Type, Bundle and Entity ID are special cases: they apply to the parent object.
  foreach (array('type', 'bundle', 'entity_id', 'revision_id') as $special_property) {
    if (isset($partial_query->$special_property)) {
      $query['_' . $special_property] = $partial_query->$special_property;
      unset($partial_query->$special_property);
    }
  }

  // Build the partial query.
  if (!empty($partial_query)) {
    $query[$field_name] = array(
      '$elemMatch' => &$partial_query,
    );
  }

  // For a count query, return the count now.
  if ($options['count']) {
    return $collection->count($query);
  }

  $cursor = $collection->find($query);

  if (!empty($options['cursor'])) {
    $cursor->skip($options['cursor']);
  }

  if ($options['limit'] != FIELD_QUERY_NO_LIMIT) {
    $cursor->limit($options['limit']);
  }

  // Now, execute the query and fetch stub objects from it.
  $return = array();
  $obj_count = 0;
  foreach ($cursor as $record) {
    $options['cursor']++;
    list($object_type, $object_key) = explode(':', $record['_id'], 2);
    $return[$record['_type']][$object_key] = entity_create_stub_entity($record['_type'], array($record['_entity_id'], $record['_revision_id'], $record['_bundle']));
    $obj_count++;
  }

  // The query is complete when it returned less rows than asked for.
  if ($options['limit'] != FIELD_QUERY_NO_LIMIT && $obj_count < $options['limit']) {
    $options['cursor'] = FIELD_QUERY_COMPLETE;
  }

  return $return;
}

/**
 * Implement hook_field_attach_rename_bundle().
 */
function mongodb_field_storage_field_attach_rename_bundle($obj_type, $bundle_old, $bundle_new) {
  _mongodb_field_storage_collection('current')->update(array('_bundle' => $bundle_old), array('_bundle' => $bundle_new), array('multiple' => TRUE));
  _mongodb_field_storage_collection('revision')->update(array('_bundle' => $bundle_old), array('_bundle' => $bundle_new), array('multiple' => TRUE));
}

/**
 * Implements hook_entity_insert().
 */
function mongodb_field_storage_entity_insert($entity, $entity_type) {
  mongodb_field_storage_field_storage_write($entity_type, $entity, NULL, array(), TRUE);
}

/**
 * Implements hook_entity_update().
 */
function mongodb_field_storage_entity_update($entity, $entity_type) {
  mongodb_field_storage_field_storage_write($entity_type, $entity, NULL, array(), TRUE);
}

/**
 * Implements hook_field_attach_delete.
 */
function mongodb_field_storage_field_attach_delete($entity_type, $entity) {
  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);
  $_id = $entity_type . ':' . $entity_id;
  _mongodb_field_storage_collection()->remove(array('_id' => $_id));
  if ($revision_id) {
    $_id = $entity_type . ':' . $revision_id;
    _mongodb_field_storage_collection('revision')->remove(array('_id' => $_id));
  }
}
