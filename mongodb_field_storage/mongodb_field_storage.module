<?php
// $Id$

/**
 * @file
 * Implementation of the field storage API for MongoDB.
 */

/**
 * Implement hook_field_storage_info().
 */
function mongodb_field_storage_field_storage_info() {
  return array(
    'mongodb_field_storage' => array(
      'label' => t('MongoDB field storage'),
      'description' => t('Stores nodes and fields in a MongoDB database.'),
    ),
  );
}

/**
 * Implement hook_field_storage_details().
 */
function mongodb_field_storage_field_storage_details($field, $instance) {
  // We probably want to implement that at one point, but this is informative only.
}

/**
 * Get the collection used to store fields current values.
 */
function _mongodb_field_storage_collection($type = 'current') {
  static $collections = array();
  if (!isset($collections[$type])) {
    $m = new Mongo();
    $db = $m->selectDB("drupal");
    $collections[$type] = $db->selectCollection("fields_" . $type);
  }
  return $collections[$type];
}

/**
 * Implement hook_field_storage_create_field().
 */
function mongodb_field_storage_field_storage_create_field($field) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_update_field().
 */
function mongodb_field_storage_field_storage_update_field($field, $prior_field, $has_data) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_delete_field().
 */
function mongodb_field_storage_field_storage_delete_field($field) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_load().
 */
function mongodb_field_storage_field_storage_load($obj_type, $objects, $age, $fields, $options) {
  $load_current = $age == FIELD_LOAD_CURRENT;

  // Fetch information about the fields and prepare the keys.
  $keys = array();
  $field_names = array();
  $saved_fields = array();
  foreach ($fields as $field_id => $ids) {
    $field = field_info_field_by_id($field_id);
    $saved_fields[$field_id] = $field;

    // Add this fields' id to the list.
    foreach ($ids as $id) {
      $keys[$obj_type . ':' . $id] = TRUE;
    }
  }

  // Execute the query and save the fields to the parent object.
  $collection = $load_current ? _mongodb_field_storage_collection('current') : _mongodb_field_storage_collection('revision');
  $result = $collection->find(array('_id' => array('$in' => array_keys($keys))));

  foreach ($result as $id => $object) {
    list($object_type, $object_id) = explode(':', $object['_entity_id'], 2);
    foreach ($saved_fields as $field_id => $field) {
      $field_name = $field['field_name'];
      if (isset($object[$field_name])) {
        $objects[$object_id]->{$field_name} = $object[$field_name];
      }
      else {
        $objects[$object_id]->{$field_name} = array();
      }
    }
  }
}

/**
 * Implement hook_field_storage_write().
 */
function mongodb_field_storage_field_storage_write($obj_type, $object, $op, $fields) {
  // Note: We assume that the $object that is passed here is the fully-loaded
  // object. All fields are assumed to be in that object.

  list($entity_id, $revision_id, $bundle) = entity_extract_ids($obj_type, $object);

  $object = clone $object;
  $object->_id = $obj_type . ':' . $entity_id;
  $object->_entity_id = $obj_type . ':' . $entity_id;
  $object->_obj_type = $obj_type;
  $object->_bundle = $bundle;

  // Prepare the field structure.
  foreach ($fields as $field_id) {
    $field = field_info_field_by_id($field_id);
    $field_name = $field['field_name'];

    if (isset($object->$field_name)) {
      foreach ($object->$field_name as $language => $values) {
        if (!isset($values)) {
          $values = array();
        }
        foreach ($values as $delta => $column_values) {
          // We have to make sure we don't store invalid deltas.
          if ($delta < 0 || ($field['cardinality'] && $delta >= $field['cardinality'])) {
            unset($object->{$field_name}[$language][$delta]);
          }
        }
      }
    }
    else {
      $object->$field_name = array();
    }

    // Store each field value in the query db too.
    _mongodb_field_storage_collection('query')->remove(array('type' => $obj_type, 'entity_id' => $entity_id));
    if (isset($revision_id)) {
      _mongodb_field_storage_collection('query_revision')->remove(array('type' => $obj_type, 'entity_id' => $entity_id, 'revision_id' => $revision_id));
    }
    foreach ($object->$field_name as $language => $values) {
      if (!isset($values)) {
        $values = array();
      }
      foreach ($values as $delta => $column_values) {
        $column_values += array(
          'field' => $field_name,
          'type' => $obj_type,
          'bundle' => $bundle,
          'entity_id' => $entity_id,
          'revision_id' => $revision_id,
          'language' => $language,
          'delta' => $delta,
        );

        _mongodb_field_storage_collection('query')->save($column_values);
        _mongodb_field_storage_collection('query_revision')->save($column_values);
      }
    }
  }

  _mongodb_field_storage_collection('current')->save($object);
  if (isset($revision_id)) {
    $object->_id = $obj_type . ':' . $revision_id;
    _mongodb_field_storage_collection('revision')->save($object);
  }
}

/**
 * Implement hook_field_storage_delete().
 *
 * This function deletes data for all fields for an object from the database.
 */
function mongodb_field_storage_field_storage_delete($obj_type, $object, $fields) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($obj_type, $object);
  _mongodb_field_storage_collection('current')->remove(array(
    '_id' => $obj_type . ':' . $entity_id,
  ));
  _mongodb_field_storage_collection('revision')->remove(array(
    '_entity_id' => $obj_type . ':' . $entity_id,
  ));

  _mongodb_field_storage_collection('query')->remove(array('type' => $obj_type, 'entity_id' => $entity_id));
  _mongodb_field_storage_collection('query_revision')->remove(array('type' => $obj_type, 'entity_id' => $entity_id, 'revision_id' => $revision_id));
}

/**
 * Implement hook_field_storage_delete_revision().
 *
 * This function actually deletes the data from the database.
 */
function mongodb_field_storage_field_storage_delete_revision($obj_type, $object, $fields) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($obj_type, $object);
  _mongodb_field_storage_collection('revision')->remove(array(
    '_id' => $obj_type . ':' . $revision_id,
    '_entity_id' => $obj_type . ':' . $entity_id,
  ));
  _mongodb_field_storage_collection('query_revision')->remove(array('type' => $obj_type, 'entity_id' => $entity_id, 'revision_id' => $revision_id));
}

/**
 * Implement hook_field_storage_delete_instance().
 *
 * This function simply marks for deletion all data associated with the field.
 */
function mongodb_field_storage_field_storage_delete_instance($instance) {
  // TODO: figure out what to do.
}

/**
 * Implement hook_field_storage_query().
 */
function mongodb_field_storage_field_storage_query($field_id, $conditions, $options) {
  $load_current = $options['age'] == FIELD_LOAD_CURRENT;

  $field = field_info_field_by_id($field_id);
  $field_name = $field['field_name'];

  $collection = $load_current ? _mongodb_field_storage_collection('query') : _mongodb_field_storage_collection('query_revision');

  $query = array(
    'field' => $field_name,
  );

  foreach ($conditions as $condition) {
    // A condition is either a (column, value, operator) triple, or a
    // (column, value) pair with implied operator.
    @list($column, $value, $operator) = $condition;

    // MongoDB doesn't easily supports multiple conditions on the same field.
    if (isset($query[$column])) {
      throw new FieldQueryException(t("Unsupported query: MongoDB doesn't support multiple conditions on the same column."));
    }

    if (!$operator) {
      $operator = is_array($value) ? 'IN' : '=';
    }

    $simple_operators = array(
      '!=' => '$ne',
      '>' => '$gt',
      '>=' => '$gte',
      '<' => '$lt',
      '<=' => '$lte',
      'IN' => '$in',
      'NOT IN' => '$nin',
    );

    if ($operator == '=') {
      $query[$column] = $value;
    }
    elseif (isset($simple_operators[$operator])) {
      $query[$column][$simple_operators[$operator]] = $value;
    }
    elseif ($operator == 'BETWEEN') {
      $query[$column] = array(
        '$lte' => $value[0],
        '$gte' => $value[1]
      );
    }
    else if ($operator == 'STARTS_WITH') {
      $query[$column] = new MongoRegex('/^' . preg_quote($value) . '/');
    }
    else if ($operator == 'ENDS_WITH') {
      $query[$column] = new MongoRegex('/' . preg_quote($value) . '$/');
    }
    else if ($operator == 'CONTAINS') {
      $query[$column] = new MongoRegex('/' . preg_quote($value) . '/');
    }
    else {
      throw new FieldQueryException(t("Unsupported query: unsupported opperator %operator.", array('%operator' => $operator)));
    }
  }

  // For a count query, return the count now.
  if ($options['count']) {
    $cursor = $collection->find($query);
    $results = array();
    foreach ($cursor as $record) {
      // If querying all revisions and the entity type has revisions, we need
      // to key the results by revision_ids.
      $entity_type = entity_get_info($record['type']);
      $id = ($load_current || empty($entity_type['object keys']['revision'])) ? $record['entity_id'] : $record['revision_id'];
      $results[$id] = TRUE;
    }
    return count($results);
  }

  $cursor = $collection->find($query);

  if (!empty($options['cursor'])) {
    $cursor->skip($options['cursor']);
  }

  if ($options['limit'] != FIELD_QUERY_NO_LIMIT) {
    $cursor->limit($options['limit']);
  }

  // Now, execute the query and fetch stub objects from it.
  $return = array();
  $obj_count = 0;
  foreach ($cursor as $record) {
    $options['cursor']++;

    // If querying all revisions and the entity type has revisions, we need
    // to key the results by revision_ids.
    $entity_type = entity_get_info($record['type']);
    $id = ($load_current || empty($entity_type['object keys']['revision'])) ? $record['entity_id'] : $record['revision_id'];

    $return[$record['type']][$id] = entity_create_stub_entity($record['type'], array($record['entity_id'], $record['revision_id'], $record['bundle']));
    $obj_count++;
  }

  // The query is complete when it returned less rows than asked for.
  if ($options['limit'] != FIELD_QUERY_NO_LIMIT && $obj_count < $options['limit']) {
    $options['cursor'] = FIELD_QUERY_COMPLETE;
  }

  return $return;
}

/**
 * Implement hook_field_attach_rename_bundle().
 */
function mongodb_field_storage_field_attach_rename_bundle($obj_type, $bundle_old, $bundle_new) {
  _mongodb_field_storage_collection('current')->update(array('_bundle' => $bundle_old), array('_bundle' => $bundle_new), array('multiple' => TRUE));
  _mongodb_field_storage_collection('revision')->update(array('_bundle' => $bundle_old), array('_bundle' => $bundle_new), array('multiple' => TRUE));
}
