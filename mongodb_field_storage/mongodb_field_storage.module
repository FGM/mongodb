<?php
// $Id$

/**
 * @file
 * Implementation of the field storage API for MongoDB.
 */

/**
 * Implement hook_field_storage_info().
 */
function mongodb_field_storage_field_storage_info() {
  return array(
    'mongodb_field_storage' => array(
      'label' => t('MongoDB field storage'),
      'description' => t('Stores nodes and fields in a MongoDB database.'),
    ),
  );
}

/**
 * Implement hook_field_storage_details().
 */
function mongodb_field_storage_field_storage_details($field) {
  // We probably want to implement that at one point, but this is informative only.
}

/**
 * Implement hook_field_storage_create_field().
 */
function mongodb_field_storage_field_storage_create_field($field) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_update_field().
 */
function mongodb_field_storage_field_storage_update_field($field, $prior_field, $has_data) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_delete_field().
 */
function mongodb_field_storage_field_storage_delete_field($field) {
  // Nothing to do?
}

/**
 * Implement hook_field_storage_load().
 */
function mongodb_field_storage_field_storage_load($entity_type, $entities, $age, $fields, $options) {
  $load_current = $age == FIELD_LOAD_CURRENT;

  // Fetch information about the fields and prepare the keys.
  $keys = array();
  $field_names = array();
  $saved_fields = array();
  foreach ($fields as $field_id => $ids) {
    $field = field_info_field_by_id($field_id);
    $saved_fields[$field_id] = $field;

    // Add this fields' id to the list.
    foreach ($ids as $id) {
      $keys[] = (int) $id;
    }
  }

  // Execute the query and save the fields to the parent entity.
  $collection_name = $load_current ? 'fields_current' : 'fields_revision';
  $collection = mongodb_collection($collection_name, $entity_type);
  $result = $collection->find(array('_id' => array('$in' => $keys)));

  foreach ($result as $entity_id => $document) {
    foreach ($document['@fields'] as $delta => $field_data) {
      foreach ($saved_fields as $field_id => $field) {
        $field_name = $field['field_name'];
        if (isset($field_data[$field_name])) {
          $language = isset($field_data[$field_name]['@language']) ? $field_data[$field_name]['@language'] : LANGUAGE_NONE;
          unset($field_data[$field_name]['@language']);
          $entities[$entity_id]->{$field_name}[$language][$delta] = $field_data[$field_name];
        }
      }
    }
  }
}

/**
 * Implement hook_field_storage_write().
 */
function mongodb_field_storage_field_storage_write($entity_type, $entity, $op, $fields, $entity_write = FALSE) {
  $wrote = &drupal_static(__FUNCTION__, array());
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  // There is always a field_attach_insert/update call followed by an
  // entity_insert/update. field_attach does not call storage_write needlessly
  // so we need to make sure if the entity was not saved during field_attach,
  // it will be during entity write. The static is set during attach write if
  // one happened and always unset on entity write.
  if ($entity_write) {
    if (isset($wrote[$entity_type][$entity_id])) {
      unset($wrote[$entity_type][$entity_id]);
      return;
    }
  }
  else {
    $wrote[$entity_type][$entity_id] = TRUE;
  }

  $save = array(
    '_id' => (int) $entity_id,
    '@bundle' => $bundle,
    '@fields' => array(),
  );
  if (isset($revision_id)) {
    $save['@revision_id'] = (int) $revision_id;
  }

  // Add the base table's fields to the new entity.
  $entity_info = entity_get_info($entity_type);
  // Although it's rare not to define a base table, test entities for sure
  // don't.
  if (isset($entity_info['base table'])) {
    $table_schema = drupal_get_schema($entity_info['base table']);
    foreach ($table_schema['fields'] as $field_name => $column_definition) {
      if (isset($entity->$field_name)) {
        $save[$field_name] = _mongodb_field_storage_value($column_definition['type'], $entity->$field_name);
      }
    }
  }

  // Add the fieldapi fields to the new entity
  foreach ($fields as $field_id) {
    $field = field_info_field_by_id($field_id);
    $field_name = $field['field_name'];
    $field_values = array();
    if (isset($entity->$field_name)) {
      foreach ($entity->$field_name as $language => $values) {
        // According to field.test, we should not save anything for NULL.
        if (isset($values)) {
          foreach ($values as $delta => $column_values) {
            // We have to make sure we don't store invalid deltas.
            if ($delta >= 0 && ($field['cardinality'] <= 0 || $delta < $field['cardinality'])) {
              foreach ($column_values as $column_name => $column_value) {
                if (isset($field['columns'][$column_name])) {
                  $save['@fields'][$delta][$field_name][$column_name] = _mongodb_field_storage_value($field['columns'][$column_name]['type'], $column_values[$column_name]);
                }
              }
              if ($language != LANGUAGE_NONE) {
                $save['@fields'][$delta][$field_name]['@language'] = $language;
              }
            }
          }
        }
      }
    }
  }

  // Save the entity.
  mongodb_collection('fields_current', $entity_type)->save($save);
  if (isset($revision_id)) {
    $save['@entity_id'] = (int) $entity_id;
    $save['_id'] = (int) $revision_id;
    unset($save['@revision_id']);
    $collection = mongodb_collection('fields_revision', $entity_type);
    $collection->save($save);
  }
}

function _mongodb_field_storage_value($type, $value) {
  switch ($type) {
    case 'int':
    case 'serial':
      return (int) $value;
    case 'float':
      return (float) $value;
    default:
      return $value;
  }
}


/**
 * Implement hook_field_storage_delete().
 *
 * This function deletes data for all fields for an entity from the database.
 */
function mongodb_field_storage_field_storage_delete($entity_type, $entity, $fields) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

  mongodb_collection('fields_current', $entity_type)->remove(array(
    '_id' => (int) $entity_id,
  ));
  mongodb_collection('fields_revision', $entity_type)->remove(array(
    '@entity_id' => (int) $entity_id,
  ));
}

/**
 * Implement hook_field_storage_delete_revision().
 *
 * This function actually deletes the data from the database.
 */
function mongodb_field_storage_field_storage_delete_revision($entity_type, $entity, $fields) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  mongodb_collection('fields_revision', $entity_type)->remove(array(
    '_id' => (int) $revision_id,
  ));
}

/**
 * Implement hook_field_storage_delete_instance().
 *
 * This function simply marks for deletion all data associated with the field.
 */
function mongodb_field_storage_field_storage_delete_instance($instance) {
  // TODO: figure out what to do.
}

/**
 * Implement hook_field_storage_query().
 */
function mongodb_field_storage_field_storage_query($field_id, $conditions, $options) {
  return array();
}

/**
 * Implement hook_field_attach_rename_bundle().
 */
function mongodb_field_storage_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  mongodb_collection('fields_current', $entity_type)->update(array('@bundle' => $bundle_old), array('@bundle' => $bundle_new), array('multiple' => TRUE));
  mongodb_collection('fields_revision', $entity_type)->update(array('@bundle' => $bundle_old), array('@bundle' => $bundle_new), array('multiple' => TRUE));
}

/**
 * Implements hook_entity_insert().
 */
function mongodb_field_storage_entity_insert($entity, $entity_type) {
  mongodb_field_storage_field_storage_write($entity_type, $entity, NULL, array(), TRUE);
}

/**
 * Implements hook_entity_update().
 */
function mongodb_field_storage_entity_update($entity, $entity_type) {
  mongodb_field_storage_field_storage_write($entity_type, $entity, NULL, array(), TRUE);
}

/**
 * Implements hook_field_attach_delete.
 */
function mongodb_field_storage_field_attach_delete($entity_type, $entity) {
  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);
  mongodb_collection('fields_current', $entity_type)->remove(array('_id' => (int) $entity_id));
  if ($revision_id) {
    mongodb_collection('fields_revision', $entity_type)->remove(array('_id' => (int) $revision_id));
  }
}
